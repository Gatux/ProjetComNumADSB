\documentclass[11pt]{article}
\usepackage[left=1in, right=1in, top=1in, bottom=1in]{geometry}
\usepackage{layout}
\usepackage{ucs}
\usepackage[french]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{array}
\usepackage{stmaryrd}
\usepackage{fourier}
\usepackage[T1]{fontenc}
\usepackage{enumitem}
\usepackage[frenchb]{babel}
\usepackage{pgfplots}



\title{\textbf{Compte rendu de projet - TS226}\\Simulation d'un émetteur / récepteur ADS-B}
\author{Maxime PETERLIN - \texttt{maxime.peterlin@enseirb-matmeca.fr}\\
Gabriel VERMEULEN - \texttt{gabriel@vermeulen.email} \\\\{ENSEIRB-MATMECA, Bordeaux}}
\date{19 janvier 2014}


\begin{document}

\maketitle
\tableofcontents

\newpage

\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

\section{Étude théorique}

	La modulation en position d'amplitude est utilisée pour la transmission de signaux ADS-B. 
	
	\begin{figure}[!h]
	\centering
		\includegraphics[scale=0.6]{img/p0p1.png}
			\caption{Tracé des impultions $p_0(t)$ et $p_1(t)$}
			\label{p0p1}
\end{figure}
	
	On a alors l'enveloppe complexe du signal émis qui est la suivante :
	\[
		s_l(t) = \sum \limits_{k \in \mathbb{Z}} p_{b_k}(t-kT_s)
	\]
	avec $T_s = 1\mu s$ le temps de l'impulsion élémentaire et
	\[
		p_{b_k}(t) =
		\begin{cases}
				p_0(t)\text{, si } b_k = 0\\
				p_1(t)\text{, si } b_k = 1
		\end{cases}
	\]
	\newline
	
	$s_l$ peut également s'exprimer en fonction des symboles émis $A_k$ et de la forme d'onde biphase donnée ci-dessous.
	
	% Figure de la forme d'onde biphase
	\begin{figure}[!h]
	\centering
		\includegraphics[scale=0.6]{img/p.png}
			\caption{Filtre de mise en forme}
			\label{p}
\end{figure}
	
	\begin{align*}
		s_l(t) &= \sum \limits_{k \in \mathbb{Z}} p_{b_k}(t_kT_s) \\
		&= \sum \limits_{\substack{k \in \mathbb{Z}\\b_k = 0}} p_0(t-kT_s) + \sum \limits_{\substack{k \in \mathbb{Z}\\b_k = 1}} p_1(t-kT_s)\\
		&= 0.5 + \sum \limits_{b_k = 0} p(t-kT_s) - \sum \limits_{b_k = 1} p(t-kT_s)\\
		s_l(t) &= 0.5 + \sum \limits_{b_k = 0} A_k p(t-kT_s) + \sum \limits_{b_k = 1} A_k p(t-kT_s)
	\end{align*}
Finalement, on obtient :
	\[
	\boxed{s_l(t) = 0.5 + \sum \limits_{k \in \mathbb{Z}} A_k p(t-kT_s) }	
	\]
avec 
	\[
		A_k =
		\begin{cases}
				
				1\text{, si } b_k = 0\\
				-1\text{, si } b_k = 1
		\end{cases}
	\]
	\newline
	
	En réception, on aura les filtres adaptés $p_0^*$ et $p_1^*$ qui ont pour but de maximiser le SNR. De plus, afin de simplifier l'étape de décision et la rendre plus fiable, il faut supprimer l'interférence entre symboles, ce qui est rendu possible si les couples de filtres $(p_0(t), p_0^*(-t))$ et $(p_1(t), p_1^*(-t))$ respectent le critère de Nyquist :
	\[
		\sum \limits_{n=-\infty}^\infty P(f - \frac{n}{T_b}) = T_b
	\]
	Avec $T_b = \frac{T_s}{2}$ le temps de l'impulsion et $P$ la transformée de Fourier du filtre en réception.\newline
	Dans notre cas, les filtres en réception $p_0^*(-t)$ et $p_1^*(-t)$ sont, à un décalage temporel près, des portes de largeur $\frac{T_s}{2}$, ainsi leur transformée de Fourier est $\frac{T_s}{2}sinc(f\frac{T_s}{2})$. On remarque que pour $f = \frac{n}{T_b}$ avec $n \in \mathbb{n}$ on a $sinc(f\frac{T_s}{2}) = 0$. Ainsi, le critère de Nyquist est vérifié pour les deux filtres en réception.
	\[
		\boxed{\sum \limits_{n=-\infty}^\infty P(f - \frac{n}{T_b}) = \frac{Ts}{2}sinc(0) = \frac{Ts}{2}}
	\]
	
On veut à présent calculer la DSP du signal $s_l$ à l'aide de l'autocorrélation moyennée de ce dernier. On commence par calculer le moment d'ordre 1 de $s_l$ :
\begin{align*}
	m_{s_l}(t) &= E[s_l(t)] = E[0.5 + \sum \limits_{k \in \mathbb{Z}} A_k p(t-kT_s)]\\
	m_{s_l}(t) &= 0.5 + \sum \limits_{k \in \mathbb{Z}} \underbrace{E[A_k]}_{0.5\cdot 1 + 0.5 \cdot -1} p(t-kT_s)
\end{align*}
\[
	m_{s_l}(t) = 0.5
\]
On remarque que ce moment d'ordre 1 est indépendant du temps.\\

A présent nous allons calculer l'autocorrélation du signal $s_l$ : 
\begin{align*}
	E[s_l(t)s_l^*(t-\tau)] &= \sum \limits_{k} E[A^2_k p(t-kT_s)p(t-\tau-kT_s)]\\
	&= \sum \limits_{k, k'} E[A_k p(t-kT_s) \cdot A_{k'}p(t-\tau-kT_s)]
\end{align*}

On sait que $p(t-kT_s) \neq 0$, si
\[
	0 < t-kT_s < T_s \Leftrightarrow \frac{t}{T_s}-1 < k < \frac{t}{T_s}
\]

Comme $k \in \mathbb{Z}$, on en déduit que $k = \left\lfloor \frac{t}{T_s} \right\rfloor$
Ainsi, 
\begin{align*}
	E[s_l(t)s_l^*(t-\tau)] &= E[A_k]E[A_k']p(t- \left\lfloor \frac{t}{T_s} \right\rfloor T_s) p(t-\tau- \left\lfloor \frac{t-\tau}{T_s} \right\rfloor T_s)\\
\end{align*}

Finalement,
\[
\boxed{R_{s_l}(t, \tau) = 
	\begin{cases}
		p(t- \left\lfloor \frac{t}{T_s} \right\rfloor T_s) p(t-\tau- \left\lfloor \frac{t-\tau}{T_s} \right\rfloor T_s)\text{, si }\left\lfloor \frac{t}{T_s} \right\rfloor=\left\lfloor \frac{t-\tau}{T_s} \right\rfloor\\
		0\text{, si }\left\lfloor \frac{t}{T_s} \right\rfloor \neq \left\lfloor \frac{t-\tau}{T_s} \right\rfloor
	\end{cases}}
\]

Nous allons maintenant montrer que le signal est cyclo-stationnaire :
\[
	R_{s_l}(t+T_s, \tau) = 
	\begin{cases}
		p(t + T_s- \left\lfloor \frac{t+ T_s}{T_s} \right\rfloor T_s) p(t+ T_s-\tau- \left\lfloor \frac{t+ T_s-\tau}{T_s} \right\rfloor T_s)\text{, si }\left\lfloor \frac{t+ T_s}{T_s} \right\rfloor=\left\lfloor \frac{t+ T_s-\tau}{T_s} \right\rfloor\\
		0\text{, si }\left\lfloor \frac{t+ T_s}{T_s} \right\rfloor \neq \left\lfloor \frac{t+ T_s-\tau}{T_s} \right\rfloor
	\end{cases}}
\]
\[
	R_{s_l}(t+T_s, \tau) = 
	\begin{cases}
		p(t + T_s -T_s- \left\lfloor \frac{t}{T_s} \right\rfloor T_s) p(t+ T_s-T_s-\tau- \left\lfloor \frac{t-\tau}{T_s} \right\rfloor T_s)\text{, si }\left\lfloor \frac{t}{T_s} \right\rfloor=\left\lfloor \frac{t-\tau}{T_s} \right\rfloor\\
		0\text{, si }\left\lfloor \frac{t}{T_s} \right\rfloor \neq \left\lfloor \frac{t-\tau}{T_s} \right\rfloor
	\end{cases}}
\]
On a alors :
\[
	\boxed{R_{s_l}(t+T_s, \tau) = R_{s_l}(t, \tau)}
\]
De plus, on a vu que le moment d'ordre 1 est indépendant du temps, le signal $s_l$ est bien cyclo-stationnaire.

Nous pouvons à présent calculer l'autocorrélation moyennée du signal $s_l$. Ainsi, pour $\tau \in [0, T_s]$, on a :
\begin{align*}
	\tilde{R}_{s_l}(\tau) &= \frac{1}{T_s} \int \limits_0^{T_s} R_{s_l}(t, \tau) dt\\
	&= \frac{1}{T_s} \int \limits_0^{T_s} p(t- \left\lfloor \frac{t}{T_s} \right\rfloor T_s) p(t-\tau- \left\lfloor \frac{t-\tau}{T_s} \right\rfloor T_s) dt\\
\end{align*}

Si $\tau < \frac{T_s}{2}$,
\begin{align*}
	\tilde{R}_{s_l}(\tau) &= \frac{1}{T_s} \int \limits_0^{\frac{T_s}{2}} \frac{1}{4} dt - \frac{1}{T_s} \int \limits_{\frac{T_s}{2}}^{\frac{T_s}{2} + \tau} \frac{1}{4} dt + \frac{1}{T_s} \int \limits_{\frac{T_s}{2} + \tau}^{T_s} \frac{1}{4} dt\\
	&= \frac{1}{4} - \frac{3\tau}{4T_s}
\end{align*}

Si $\frac{T_s}{2} < \tau < T_s$,
\begin{align*}
	\tilde{R}_{s_l}(\tau) &= - \frac{1}{T_s} \int \limits_{\tau}^{T_s} \frac{1}{4} dt\\
	&= \frac{\tau}{4T_s} - \frac{1}{4}
\end{align*}

En résumé, on a pour $\tau \geq 0$
\[
\boxed{
	\tilde{R}_{s_l}(\tau) =
	\begin{cases}
		\frac{1}{4} - \frac{3\tau}{4T_s}\text{, si }0 \leq \tau < \frac{T_s}{2}\\
		\frac{\tau}{4T_s} - \frac{1}{4}\text{, si }\frac{T_s}{2} \leq \tau < T_s\\
		0\text{, sinon}
	\end{cases}
	}
\]
%figure du tracé de R_sl

Calculons à présent la densité spectrale de puissance $\Gamma_{s_l}$ du signal $s_l$.
On a 
\[
	p(t) = -\frac{1}{2}\Pi_{\frac{T_s}{2}}(t-\frac{T_s}{4}) + \frac{1}{2}\Pi(t-\frac{3T_s}{4})
\]
Ainsi, la transformée de Fourier s'exprime de la manière suivante :
\begin{align*}
	P(f) &= \frac{1}{2}\frac{T_s}{2}sinc(f\frac{T_s}{2})e^{-j2\pi f \frac{T_s}{4}}+ \frac{1}{2}\frac{T_s}{2}sinc(f\frac{T_s}{2})e^{-j2\pi f \frac{3T_s}{4}}\\
	&= \frac{T_s}{4} sinc(f\frac{T_s}{2})[e^{-j2\pi f \frac{3T_s}{4}} - e^{-j2\pi f \frac{T_s}{4}}]
\end{align*}
La DSP a alors l'expression suivante :
\begin{align*}
	\Gamma_{s_l} &=  | P(f) |^2 = \frac{T_s^2}{16}sinc^2(f\frac{T_s}{2})[-2 j sin(\pi f \frac{T_s}{2})]^2\\
	&= \frac{T_s^2}{16}sinc^2(f\frac{T_s}{2})[4 sin^2(\pi f \frac{T_s}{2})]\\
\end{align*}
\[
	\boxed{
	\Gamma_{s_l} = \frac{T_s^2}{4}sinc^2(f\frac{T_s}{2})sin^2(\pi f \frac{T_s}{2})}
\]

\newpage

\subsection{Description de la chaîne de transmission}

Pour simuler la modulation PPM, un message binaire aléatoire est initialement généré. Ce dernier est ensuite transformé en symbole appartement à l'ensemble \{ -1, 1 \} puis est sur-échantillonné. Enfin on applique le filtre de mise en forme ainsi qu'un décalage d'amplitude de $+0.5$.

\begin{figure}[!h]
	\centering
		\includegraphics[scale=0.6]{img/p.png}
			\caption{Filtre de mise en forme}
			\label{p}
\end{figure}

Le résultat obtenue est le signal $s_l(t)$ qui corresponds à la sortie du bloc d'émission.

\begin{figure}[!h]
	\centering
		\includegraphics[scale=0.6]{img/sl.png}
			\caption{Tracé de $s_l(t)$ pour les 25 premier bits}
			\label{sl}
\end{figure}

\newpage

Le diagramme de l'oeil nous permet de vérifier qu'il n'y a aucun défaut de synchronisation, de distorsion ou de gigue. Le tracé suivant est fait avant émission, il est donc parfait :

\begin{figure}[!h]
	\centering
		\includegraphics[scale=0.6]{img/eye.png}
			\caption{Diagramme de l'oeil pour les 100 premier bits}
			\label{eye}
\end{figure}

La densité spectrale de puissance du signal nous permet de voir la répartition fréquentielle de la puissance du signal. Un tracé théorique et réel est présenté sur la figure suivante. On peut remarquer, outre le décalage d'amplitude entre les deux courbes, le fait que le signal réel aléatoire résultant d'une seule réalisation engendre une courbe moins lissée que celle théorique.

\begin{figure}[!h]
	\centering
		\includegraphics[scale=0.6]{img/dsp.png}
			\caption{Tracé théorique et réel de la DSP de $s_l(t)$}
			\label{dsp}
\end{figure}

On considérera que le canal se comporte comme un filtre passe-tout.\\
A la réception, le signal récupéré est constitué du signal émis auquel est ajouté un bruit de réception modélisé par un bruit blanc gaussien centré en 0.\\
Tout d'abord un décalage d'amplitude  de $-0.5$ est appliqué au signal. Ensuite ce dernier est filtré par un filtre adapté dont voici le tracé :

\begin{figure}[!h]
	\centering
		\includegraphics[scale=0.6]{img/padapt.png}
			\caption{Filtre adapté}
			\label{padapt}
\end{figure}

Il ne reste qu'à sous-échantillonner au rythme du temps symbole et à effectuer la décision par rapport à l'amplitude du signal. Le message est ainsi récupéré.

\subsection{Etude du taux d'erreur binaire en fonction du SNR}

L'étude du lien entre le taux d'erreur binaire et du ratio signal sur bruit permet de mesurer les performances de la chaîne de transmission PPM malgré l'ajout d'un bruit blanc gaussien centré au signal émis. On peut observer un décalage entre la courbe théorique et la courbe réelle.

\begin{figure}[!h]
	\centering
		\includegraphics[scale=0.6]{img/snr_teb1.png}
			\caption{Courbes réelles et théoriques du TEB en fonction du SNR en db}
			\label{snr_teb1}
\end{figure}

\subsection{Synchronisation en temps et en fréquence}

Afin de synchroniser temporellement et fréquentiellement le signal reçu (induit respectivement par un délais de propagation et par l'effet Doppler), on calcule le maximum de la corrélation suivante.
\begin{equation}
	\rho (\delta'_t, \delta'_f) = \frac{\int \limits_{\delta'_t}^{\delta'_t+T_p} y_l(t)s_p^*(t-\delta'_t)e^{j2 \pi \delta'_f t} dt}{\sqrt{\int \limits_0^{T_p} |s_p^2(t)|dt}\sqrt{\int \limits_{\delta'_t}^{\delta'_t+T_p} |y_l(t)|^2 dt }}
	\label{sync}
\end{equation} 

Les décalage temporels et fréquentiels sont réalisés en prennant le couple $(\hat{\delta}_t, \hat{\delta}_f)$ tel que
\[
	(\hat{\delta}_t, \hat{\delta}_f) = arg\max \limits_{(\delta'_t, \delta'_f)} |\rho (\delta'_t, \delta'_f)|
\]

Grâce au théorème de Cauchy-Schwarz, on montre que $|\rho (\delta'_t, \delta'_f)| \leq 1$.
En effet, 
\[
	\frac{\int \limits_{\delta'_t}^{\delta'_t+T_p} y_l(t)s_p^*(t-\delta'_t)e^{j2 \pi \delta'_f t} dt}{\sqrt{\int \limits_0^{T_p} |s_p^2(t)|dt}\sqrt{\int \limits_{\delta'_t}^{\delta'_t+T_p} |y_l(t)|^2 dt }} \leq \frac{\sqrt{\int \limits_0^{T_p} |s_p^2(t)|dt}\sqrt{\int \limits_{\delta'_t}^{\delta'_t+T_p} |y_l(t)|^2 dt }}{\sqrt{\int \limits_0^{T_p} |s_p^2(t)|dt}\sqrt{\int \limits_{\delta'_t}^{\delta'_t+T_p} |y_l(t)|^2 dt }} \leq 1
\]
avec égalité lorsque $y_l = \lambda s_p$
\\
Lorsqu'un avion se déplace à 900 km/h, son déplacement induit un décalage de fréquence perçu par le récepteur. Ce phénomène porte le nom d'effet Doppler. Il est possible d'estimer ce décalage de fréquence grâce à la formule qui suit :

\[
	f_{rec} = \frac{c - v_{rec}}{c - v_{em}} f_{em}
\]

Avec $f_{rec}$ la fréquence reçue, $f_{em}$ la fréquence émise, $v_{rec}$ la vitesse du récepteur, $v_{em}$ la vitesse de l'émetteur et c la célérité de l'onde.\\
Ici sera considéré :
\begin{itemize}
	\item $f_{em}$ = 1090 MHz
	\item $v_{rec}$ = 0 $km.h^-1$
	\item $v_{em}$ = 900 $km.h^-1$
	\item c = 1 079 252 848,8 $km.h^-1$
\end{itemize}

Finalement on obtient $f_{rec}$ = 1 090 000 909 Hz, ce qui traduit un décalage maximum de +-909 Hz.

\subsection{Etude du taux d'erreur binaire en fonction du SNR avec la synchronisation}

Afin de gérer la synchronisation temporelle et fréquentielle, il faut modifier la chaîne de transmission.\\
Dans le bloc d'émission, il suffit d'ajouter le préambule au signal de sortie.\\
Avant d'ajout du bruit blanc gaussien centré au signal, il faut artificiellement désynchroniser le signal. Cela se fait en ajoutant des bits aléatoires avant le signal et en le multipliant par une exponentielle complexe.\\
Le bloc de réception se voit ajouter le calcul de la fonction~\eqref{sync} permettant d'estimer les deux paramètres $\delta_t$ et $\delta_f$. Il devient alors possible de démoduler le signal, puis de calculer et de tracer la nouvelle courbe du TEB en fonction du SNR.

\begin{figure}[!h]
	\centering
		\includegraphics[scale=0.6]{img/snr_teb2.png}
			\caption{Courbes réelles et théoriques du TEB en fonction du SNR en db}
			\label{snr_teb2}
\end{figure}

Il a été remarqué que la fonction établie pour estimer les paramètres $\delta_t$ et $\delta_f$ reste très sensible au bruit, ce qui peut donner des erreurs d'estimations. Lorsque c'est le cas, le TEB devient important.

\section{Implémentation sous \textsc{MATLAB}}

\subsection{Bloc d'émission}

La génération aléatoire de message s'effectue simplement avec la fonction $randi$ en précisant la taille de la matrice à générer, et l'ensemble \{ 0, 1 \} correspondant aux bits.\\
Ensuite l'association bits/symbole se fait avec un simple calcul mathématique et le sur-échantillonnage est effectué avec la fonction $upsample$.\\
Enfin, l'utilisation de la fonction $conv$ permet d'appliquer le filtre de mise en forme au signal.\\
L'ajout du préambule se fait avec une concaténation de vecteurs.

\subsection{Canal}

Le canal est considéré comme un filtre passe-tout. Il ne change donc pas le signal émis.\\
Afin de désynchroniser artificiellement le signal, il faut ajouter au signal une séquence aléatoire de bits généré avec $randi$, et multiplier chaque termes par une exponentielle complexe, de fréquence aléatoirement déterminé par la fonction $randi$.

\subsection{Bloc de réception}

La première chose à faire est d'estimer les paramètres $\delta_t$ et $\delta_f$. Pour ce faire, une boucle calcul pour un $\delta_f$ variant de -1000 Hz à 1000 Hz la convolution entre le signal multiplié par une exponentielle complexe de fréquence $\delta_f$ et le préambule. On recherche ensuite le maximum de cette convolution avec la fonction $max$ ce qui nous permet d'obtenir $\delta_t$ et $\delta_f$.\\
On peut ainsi compenser les décalages temporel et fréquentiel et sélectionner les $112*Fse$ points traduisant une trame (Fse étant le ratio fréquence d’échantillonnage sur fréquence du débit symbole).\\
Il reste a utiliser la fonction $conv$ pour appliquer le filtre adapté, puis à effectuer une simple condition \textit{supérieure à} pour la décision et on obtient le message démodulé.\\

\subsection{Décodage ADSB}

Une fois que les buffers reçus ont été démodulés et synchronisés en temps et en fréquence, on peut extraire les trames ADS-B dont nous allons à présent expliquer le décodage que nous avons implémenté via la fonction $bit2registre$.\newline
Les trames ont une longueur de 120 bits et possède la structure suivante :\newline
\begin{itemize}
	\item Préambule $\rightarrow$ 8 bits\\
	\item Format de la voix descendante $\rightarrow$ 5 bits\\
	\item Capacité $\rightarrow$ 3 bits\\
	\item Adresse OACI $\rightarrow$ 24 bits\\
	\item Données ADS-B $\rightarrow$ 56 bits\\
	\item Contrôle de parités $\rightarrow$ 24 bits\\
\end{itemize}
\newline

Tout d'abord, on vérifie que la trame est correcte grâce au CRC de polynôme générateur 
\[
	p(x) = x^{24} + x^{23} + x^{22} + x^{21} + x^{20} + x^{19} + x^{18} + x^{17} + x^{16} + x^{15} + x^{14} + x^{13} + x^{12} + x^{12} + x^{10} + x^3 + 1
\]
On peut effectuer cette opération sur \textsc{MATLAB} à l'aide de la fonction $crc.detector$ qui va générer le CRC à partir d'un polynôme générateur passé en argument, puis on vérifie que la trame est correcte grâce à $detect$ qui nous renvoie le nombre d'erreurs trouvées.\newline

S'il n'y a pas d'erreur, on récupère les 5 bits suivant le préambule afin de connaître le format de la voie descendante que l'on convertit en binaire à l'aide de $bi2de$ (on ne traitera que les trames avec \textbf{DF = 17}).\newline

Ensuite, on décode l'adresse OACI de l'appareil qui nous permettra de faire le lien entre les différentes trames reçues, car elle est propre à chaque avion (l'adresse est codée sur 24 bits et se trouve à la position 16 dans la trame). On la convertira tout d'abord en binaire, puis en hexadécimal à l'aide de la fonction $dec2hex$ afin de faciliter sa lecture.\newline

On termine par le décodage du message contenant les données transportées par la trame. Les 5 premiers bits du message permettent de connaître le format des données envoyées (FTC). On ne s'intéresse qu'aux valeurs de FTC comprises entre 1 et 4 (pour les messages d'identification) et entre 9 et 22 (en excluant la valeur 19 pour les messages de position en vol).\newline
\newline

Si le FTC est compris entre 1 et 4, on commence par créer une matrice de taille 8x6 où les colonnes correspondent aux 6 bits encodant les caractères. Un tableau contenant la correspondance entre la valeur décimale de ces 6 bits et le caractère auxquels ils correspondent est créé afin de décoder à l'aide de $cells$ le nom de l'avion.\newline

Si le FTC est compris entre 9 et 22 (mais différent de 19), on extrait l'indicateur UTC qui en position 21 dans le message, ainsi que le bit suivant qui est l'indicateur CPR. Enfin, à l'aide d'une série de calculs complexes, on récupère l'altitude, la latitude et la longitude.

\section{Résultats}



\section*{Conclusion}
\addcontentsline{toc}{section}{Conclusion}

		Ce projet nous aura permis d'étudier et de mettre en oeuvre une chaîne de communication numériques en mettant l'accent sur la partie réception. L'étude du protocole ADS-B, dont nous avons à présent une bonne compréhension, a notamment été un plus du fait de son utilisation répandue dans le secteur de l'aéronautique.\newline
		L'une des principales difficultés rencontrées a été la synchronisation temporelle et fréquentielle du signal reçu, étape cruciale du décodage des trames ADS-B.\newline
		Cependant, nous avons finalement réussi à décoder des buffers de trames en temps réel, par contre les calculs étaient trop lents par rapport au flux d'arrivé des buffers. Une grande partie d'optimisation pourrait encore être fait à ce niveau afin d'améliorer les performances de l'estimation de la position des trames qui est l'étape demandant le plus de calculs.

\end{document}
